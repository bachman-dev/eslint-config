import {
  baseRules,
  handledByTypescript,
  javascriptWithinTypescript,
  typescript,
  typescriptExtensions,
} from "../src/rules/index.js";
import type { Admonishment } from "../src/types.js";
import { join } from "path";
import { writeFile } from "fs/promises";

function admonish(admonishments: Admonishment[] | undefined): string {
  let admonishmentString = "";
  if (Array.isArray(admonishments) && admonishments.length > 0) {
    admonishments.forEach((admonishment) => {
      admonishmentString += "> [!";
      switch (admonishment.type) {
        case "caution":
          admonishmentString += "CAUTION";
          break;
        case "important":
          admonishmentString += "IMPORTANT";
          break;
        case "note":
          admonishmentString += "NOTE";
          break;
        case "tip":
          admonishmentString += "TIP";
          break;
        case "warning":
          admonishmentString += "WARNING";
      }
      admonishmentString += `]\n> ${admonishment.text}\n\n`;
    });
  }
  return admonishmentString;
}

enum Heading {
  One = 1,
  Two = 2,
  Three = 3,
  Four = 4,
  Five = 5,
  Six = 6,
}

function header(level: Heading, text: string): string {
  let headerString = "";
  for (let idx = Heading.One; idx <= level; idx++) {
    headerString += "#";
  }
  headerString += ` ${text}\n\n`;
  return headerString;
}

function json(item: unknown): string {
  return `\`\`\`json\n${JSON.stringify(item)}\n\`\`\`\n\n`;
}

function link(text: string, href: string): string {
  return `[${text}](${href})`;
}

function list(items: string[]): string {
  let listString = "";
  items.forEach((item) => {
    listString += `- ${item}\n`;
  });
  return listString;
}

function paragraph(text: string): string {
  return `${text}\n\n`;
}

const rulesPath = join(process.cwd(), "src", "rules", "README.md");

let markdown = `
${admonish([{ type: "caution", text: `This file is auto-generated by ${link("readme.ts", "/scripts/readme.ts")} and should not be edited directly.` }])}
${header(Heading.One, "Rules")}
${paragraph(`Below are all the rules in their respective categories this configuration works with, excluding any enabled by built-in configurations that don't need their settings overridden.`)}
${header(Heading.Two, "Legend")}
${list(["üõë Throws a Linting Error", "‚ö†Ô∏è Emits a Warning", "üî≤ Intentionally Disabled"])}
`;

[baseRules, handledByTypescript, javascriptWithinTypescript, typescriptExtensions, typescript].forEach((group) => {
  markdown += `${header(Heading.Two, group.name)}${paragraph(group.description)}${admonish(group.admonishments)}`;
  group.rules.forEach((rule) => {
    switch (rule.severity) {
      case "error":
        markdown += header(Heading.Three, link(`üõë ${rule.name}`, rule.url));
        break;
      case "warn":
        markdown += header(Heading.Three, link(`‚ö†Ô∏è ${rule.name}`, rule.url));
        break;
      case "off":
        markdown += header(Heading.Three, link(`üî≤ ${rule.name}`, rule.url));
        break;
    }
    if (typeof rule.settings !== "undefined") {
      markdown += header(Heading.Four, "Settings");
      if (
        ["no-restricted-syntax", "@typescript-eslint/member-ordering", "@typescript-eslint/naming-convention"].includes(
          rule.name,
        )
      ) {
        markdown += paragraph("(omitted to save space)");
      } else {
        markdown += json(rule.settings);
      }
    }
    markdown += admonish(rule.admonishments);
  });
});

await writeFile(rulesPath, markdown, "utf-8");
