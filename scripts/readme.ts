import {
  baseRules,
  handledByTypescript,
  javascriptWithinTypescript,
  typescript,
  typescriptExtensions,
} from "../src/rules/index.js";
import type { Admonishment } from "../src/types.js";
import { join } from "path";
import { writeFile } from "fs/promises";

function admonish(admonishments: Admonishment[] | undefined): string {
  let admonishmentString = "";
  admonishments?.forEach((admonishment) => {
    admonishmentString += "> [!";
    switch (admonishment.type) {
      case "caution":
        admonishmentString += "CAUTION";
        break;
      case "important":
        admonishmentString += "IMPORTANT";
        break;
      case "note":
        admonishmentString += "NOTE";
        break;
      case "tip":
        admonishmentString += "TIP";
        break;
      case "warning":
        admonishmentString += "WARNING";
    }
    admonishmentString += `]\n> ${admonishment.text}\n\n`;
  });
  return admonishmentString;
}

const heading = {
  one: 1,
  two: 2,
  three: 3,
  four: 4,
  five: 5,
  six: 6,
} as const;

type Heading = (typeof heading)[keyof typeof heading];

function header(level: Heading, text: string): string {
  return `${"#".repeat(level)} ${text}\n\n`;
}

function json(item: unknown): string {
  return `\`\`\`json\n${JSON.stringify(item)}\n\`\`\`\n\n`;
}

function link(text: string, href: string): string {
  return `[${text}](${href})`;
}

function list(items: string[]): string {
  let listString = "";
  items.forEach((item) => {
    listString += `- ${item}\n`;
  });
  return listString;
}

function paragraph(text: string): string {
  return `${text}\n\n`;
}

const rulesPath = join(process.cwd(), "src", "rules", "README.md");

let markdown = `
${admonish([{ type: "caution", text: `This file is auto-generated by ${link("readme.ts", "/scripts/readme.ts")} and should not be edited directly.` }])}
${header(heading.one, "Rules")}
${paragraph(`Below are all the rules in their respective categories this configuration works with, excluding any enabled by built-in configurations that don't need their settings overridden.`)}
${header(heading.two, "Legend")}
${list(["🛑 Throws a Linting Error", "⚠️ Emits a Warning", "🔲 Intentionally Disabled"])}
`;

[baseRules, handledByTypescript, javascriptWithinTypescript, typescript, typescriptExtensions].forEach((group) => {
  markdown += `${header(heading.two, group.name)}${paragraph(group.description)}${admonish(group.admonishments)}`;
  group.rules.forEach((rule) => {
    switch (rule.severity) {
      case "error":
        markdown += header(heading.three, link(`🛑 ${rule.name}`, rule.url));
        break;
      case "warn":
        markdown += header(heading.three, link(`⚠️ ${rule.name}`, rule.url));
        break;
      case "off":
        markdown += header(heading.three, link(`🔲 ${rule.name}`, rule.url));
        break;
    }
    if (typeof rule.settings !== "undefined") {
      markdown += header(heading.four, "Settings");
      if (
        ["no-restricted-syntax", "@typescript-eslint/member-ordering", "@typescript-eslint/naming-convention"].includes(
          rule.name,
        )
      ) {
        markdown += paragraph("(omitted to save space)");
      } else {
        markdown += json(rule.settings);
      }
    }
    markdown += admonish(rule.admonishments);
  });
});

await writeFile(rulesPath, markdown, "utf-8");
